{"ast":null,"code":"/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\nimport { w as win } from './index-7a14ecec.js';\nimport { r as raf } from './helpers-3379ba19.js';\n\n/**\r\n * A utility to calculate the size of an outline notch\r\n * width relative to the content passed. This is used in\r\n * components such as `ion-select` with `fill=\"outline\"`\r\n * where we need to pass slotted HTML content. This is not\r\n * needed when rendering plaintext content because we can\r\n * render the plaintext again hidden with `opacity: 0` inside\r\n * of the notch. As a result we can rely on the intrinsic size\r\n * of the element to correctly compute the notch width. We\r\n * cannot do this with slotted content because we cannot project\r\n * it into 2 places at once.\r\n *\r\n * @internal\r\n * @param el: The host element\r\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\r\n * @param getLabelSlot: A function that returns a reference to the slotted content.\r\n */\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\n  let notchVisibilityIO;\n  const needsExplicitNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (\n    /**\r\n     * If the notch is not being used\r\n     * then we do not need to set the notch width.\r\n     */\n    notchSpacerEl === undefined ||\n    /**\r\n     * If either the label property is being\r\n     * used or the label slot is not defined,\r\n     * then we do not need to estimate the notch width.\r\n     */\n    el.label !== undefined || getLabelSlot() === null) {\n      return false;\n    }\n    return true;\n  };\n  const calculateNotchWidth = () => {\n    if (needsExplicitNotchWidth()) {\n      /**\r\n       * Run this the frame after\r\n       * the browser has re-painted the host element.\r\n       * Otherwise, the label element may have a width\r\n       * of 0 and the IntersectionObserver will be used.\r\n       */\n      raf(() => {\n        setNotchWidth();\n      });\n    }\n  };\n  /**\r\n   * When using a label prop we can render\r\n   * the label value inside of the notch and\r\n   * let the browser calculate the size of the notch.\r\n   * However, we cannot render the label slot in multiple\r\n   * places so we need to manually calculate the notch dimension\r\n   * based on the size of the slotted content.\r\n   *\r\n   * This function should only be used to set the notch width\r\n   * on slotted label content. The notch width for label prop\r\n   * content is automatically calculated based on the\r\n   * intrinsic size of the label text.\r\n   */\n  const setNotchWidth = () => {\n    const notchSpacerEl = getNotchSpacerEl();\n    if (notchSpacerEl === undefined) {\n      return;\n    }\n    if (!needsExplicitNotchWidth()) {\n      notchSpacerEl.style.removeProperty('width');\n      return;\n    }\n    const width = getLabelSlot().scrollWidth;\n    if (\n    /**\r\n     * If the computed width of the label is 0\r\n     * and notchSpacerEl's offsetParent is null\r\n     * then that means the element is hidden.\r\n     * As a result, we need to wait for the element\r\n     * to become visible before setting the notch width.\r\n     *\r\n     * We do not check el.offsetParent because\r\n     * that can be null if the host element has\r\n     * position: fixed applied to it.\r\n     * notchSpacerEl does not have position: fixed.\r\n     */\n    width === 0 && notchSpacerEl.offsetParent === null && win !== undefined && 'IntersectionObserver' in win) {\n      /**\r\n       * If there is an IO already attached\r\n       * then that will update the notch\r\n       * once the element becomes visible.\r\n       * As a result, there is no need to create\r\n       * another one.\r\n       */\n      if (notchVisibilityIO !== undefined) {\n        return;\n      }\n      const io = notchVisibilityIO = new IntersectionObserver(ev => {\n        /**\r\n         * If the element is visible then we\r\n         * can try setting the notch width again.\r\n         */\n        if (ev[0].intersectionRatio === 1) {\n          setNotchWidth();\n          io.disconnect();\n          notchVisibilityIO = undefined;\n        }\n      },\n      /**\r\n       * Set the root to be the host element\r\n       * This causes the IO callback\r\n       * to be fired in WebKit as soon as the element\r\n       * is visible. If we used the default root value\r\n       * then WebKit would only fire the IO callback\r\n       * after any animations (such as a modal transition)\r\n       * finished, and there would potentially be a flicker.\r\n       */\n      {\n        threshold: 0.01,\n        root: el\n      });\n      io.observe(notchSpacerEl);\n      return;\n    }\n    /**\r\n     * If the element is visible then we can set the notch width.\r\n     * The notch is only visible when the label is scaled,\r\n     * which is why we multiply the width by 0.75 as this is\r\n     * the same amount the label element is scaled by in the host CSS.\r\n     * (For ion-select, see $select-floating-label-scale in select.vars.scss).\r\n     */\n    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\n  };\n  const destroy = () => {\n    if (notchVisibilityIO) {\n      notchVisibilityIO.disconnect();\n      notchVisibilityIO = undefined;\n    }\n  };\n  return {\n    calculateNotchWidth,\n    destroy\n  };\n};\nexport { createNotchController as c };","map":{"version":3,"names":["w","win","r","raf","createNotchController","el","getNotchSpacerEl","getLabelSlot","notchVisibilityIO","needsExplicitNotchWidth","notchSpacerEl","undefined","label","calculateNotchWidth","setNotchWidth","style","removeProperty","width","scrollWidth","offsetParent","io","IntersectionObserver","ev","intersectionRatio","disconnect","threshold","root","observe","setProperty","destroy","c"],"sources":["C:/Users/alarc/OneDrive/Escritorio/ProjectMovil/TellevoApp/node_modules/@ionic/core/dist/esm/notch-controller-cb5bbe6a.js"],"sourcesContent":["/*!\r\n * (C) Ionic http://ionicframework.com - MIT License\r\n */\r\nimport { w as win } from './index-7a14ecec.js';\r\nimport { r as raf } from './helpers-3379ba19.js';\r\n\r\n/**\r\n * A utility to calculate the size of an outline notch\r\n * width relative to the content passed. This is used in\r\n * components such as `ion-select` with `fill=\"outline\"`\r\n * where we need to pass slotted HTML content. This is not\r\n * needed when rendering plaintext content because we can\r\n * render the plaintext again hidden with `opacity: 0` inside\r\n * of the notch. As a result we can rely on the intrinsic size\r\n * of the element to correctly compute the notch width. We\r\n * cannot do this with slotted content because we cannot project\r\n * it into 2 places at once.\r\n *\r\n * @internal\r\n * @param el: The host element\r\n * @param getNotchSpacerEl: A function that returns a reference to the notch spacer element inside of the component template.\r\n * @param getLabelSlot: A function that returns a reference to the slotted content.\r\n */\r\nconst createNotchController = (el, getNotchSpacerEl, getLabelSlot) => {\r\n  let notchVisibilityIO;\r\n  const needsExplicitNotchWidth = () => {\r\n    const notchSpacerEl = getNotchSpacerEl();\r\n    if (\r\n    /**\r\n     * If the notch is not being used\r\n     * then we do not need to set the notch width.\r\n     */\r\n    notchSpacerEl === undefined ||\r\n      /**\r\n       * If either the label property is being\r\n       * used or the label slot is not defined,\r\n       * then we do not need to estimate the notch width.\r\n       */\r\n      el.label !== undefined ||\r\n      getLabelSlot() === null) {\r\n      return false;\r\n    }\r\n    return true;\r\n  };\r\n  const calculateNotchWidth = () => {\r\n    if (needsExplicitNotchWidth()) {\r\n      /**\r\n       * Run this the frame after\r\n       * the browser has re-painted the host element.\r\n       * Otherwise, the label element may have a width\r\n       * of 0 and the IntersectionObserver will be used.\r\n       */\r\n      raf(() => {\r\n        setNotchWidth();\r\n      });\r\n    }\r\n  };\r\n  /**\r\n   * When using a label prop we can render\r\n   * the label value inside of the notch and\r\n   * let the browser calculate the size of the notch.\r\n   * However, we cannot render the label slot in multiple\r\n   * places so we need to manually calculate the notch dimension\r\n   * based on the size of the slotted content.\r\n   *\r\n   * This function should only be used to set the notch width\r\n   * on slotted label content. The notch width for label prop\r\n   * content is automatically calculated based on the\r\n   * intrinsic size of the label text.\r\n   */\r\n  const setNotchWidth = () => {\r\n    const notchSpacerEl = getNotchSpacerEl();\r\n    if (notchSpacerEl === undefined) {\r\n      return;\r\n    }\r\n    if (!needsExplicitNotchWidth()) {\r\n      notchSpacerEl.style.removeProperty('width');\r\n      return;\r\n    }\r\n    const width = getLabelSlot().scrollWidth;\r\n    if (\r\n    /**\r\n     * If the computed width of the label is 0\r\n     * and notchSpacerEl's offsetParent is null\r\n     * then that means the element is hidden.\r\n     * As a result, we need to wait for the element\r\n     * to become visible before setting the notch width.\r\n     *\r\n     * We do not check el.offsetParent because\r\n     * that can be null if the host element has\r\n     * position: fixed applied to it.\r\n     * notchSpacerEl does not have position: fixed.\r\n     */\r\n    width === 0 &&\r\n      notchSpacerEl.offsetParent === null &&\r\n      win !== undefined &&\r\n      'IntersectionObserver' in win) {\r\n      /**\r\n       * If there is an IO already attached\r\n       * then that will update the notch\r\n       * once the element becomes visible.\r\n       * As a result, there is no need to create\r\n       * another one.\r\n       */\r\n      if (notchVisibilityIO !== undefined) {\r\n        return;\r\n      }\r\n      const io = (notchVisibilityIO = new IntersectionObserver((ev) => {\r\n        /**\r\n         * If the element is visible then we\r\n         * can try setting the notch width again.\r\n         */\r\n        if (ev[0].intersectionRatio === 1) {\r\n          setNotchWidth();\r\n          io.disconnect();\r\n          notchVisibilityIO = undefined;\r\n        }\r\n      }, \r\n      /**\r\n       * Set the root to be the host element\r\n       * This causes the IO callback\r\n       * to be fired in WebKit as soon as the element\r\n       * is visible. If we used the default root value\r\n       * then WebKit would only fire the IO callback\r\n       * after any animations (such as a modal transition)\r\n       * finished, and there would potentially be a flicker.\r\n       */\r\n      { threshold: 0.01, root: el }));\r\n      io.observe(notchSpacerEl);\r\n      return;\r\n    }\r\n    /**\r\n     * If the element is visible then we can set the notch width.\r\n     * The notch is only visible when the label is scaled,\r\n     * which is why we multiply the width by 0.75 as this is\r\n     * the same amount the label element is scaled by in the host CSS.\r\n     * (For ion-select, see $select-floating-label-scale in select.vars.scss).\r\n     */\r\n    notchSpacerEl.style.setProperty('width', `${width * 0.75}px`);\r\n  };\r\n  const destroy = () => {\r\n    if (notchVisibilityIO) {\r\n      notchVisibilityIO.disconnect();\r\n      notchVisibilityIO = undefined;\r\n    }\r\n  };\r\n  return {\r\n    calculateNotchWidth,\r\n    destroy,\r\n  };\r\n};\r\n\r\nexport { createNotchController as c };\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}